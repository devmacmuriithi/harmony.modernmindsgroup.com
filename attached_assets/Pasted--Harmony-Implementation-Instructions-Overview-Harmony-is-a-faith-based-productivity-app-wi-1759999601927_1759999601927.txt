# Harmony - Implementation Instructions

## Overview
Harmony is a faith-based productivity app with personalized AI recommendations. Users track moods, prayers, Bible reading, and interact with AI spiritual guides. The system learns from user activities to provide personalized content for spiritual growth and human flourishing.

---

## Database Schema

### Core Tables

```sql
-- Users
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  name VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Events (Central tracking table)
CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  event_type VARCHAR(50) NOT NULL, -- 'mood', 'prayer', 'bible_read', 'devotional_read', 'note_created', 'guide_chat', 'video_watched', 'song_listened', 'resource_read'
  event_data JSONB, -- Flexible storage for event details
  created_at TIMESTAMP DEFAULT NOW()
);
CREATE INDEX idx_events_user_created ON events(user_id, created_at DESC);

-- Moods
CREATE TABLE moods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  mood_type VARCHAR(50) NOT NULL, -- 'joyful', 'peaceful', 'grateful', 'sad', 'anxious', 'angry'
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Prayer Journals
CREATE TABLE prayer_journals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  is_answered BOOLEAN DEFAULT FALSE,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  answered_at TIMESTAMP
);

-- Devotionals
CREATE TABLE devotionals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255),
  content TEXT NOT NULL,
  scripture_reference VARCHAR(100),
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Bible Verses
CREATE TABLE bible_verses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  book VARCHAR(50) NOT NULL,
  chapter INTEGER NOT NULL,
  verse_start INTEGER NOT NULL,
  verse_end INTEGER,
  translation VARCHAR(10) DEFAULT 'NIV',
  notes TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Sync Notes
CREATE TABLE sync_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  ai_tags VARCHAR(100)[], -- Array of tag strings
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Spiritual Guides (Predefined agents)
CREATE TABLE spiritual_guides (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  description TEXT,
  system_prompt TEXT NOT NULL,
  avatar_emoji VARCHAR(10) DEFAULT 'üïäÔ∏è',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Conversations (Chat sessions with guides)
CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  guide_id UUID REFERENCES spiritual_guides(id) ON DELETE CASCADE,
  title VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Messages (Chat messages)
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
  role VARCHAR(20) NOT NULL, -- 'user', 'assistant', 'system'
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Prayer Chains (Public prayer requests)
CREATE TABLE prayer_chains (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  is_answered BOOLEAN DEFAULT FALSE,
  follower_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Prayer Chain Comments
CREATE TABLE prayer_chain_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  prayer_chain_id UUID REFERENCES prayer_chains(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Videos (YouTube recommendations)
CREATE TABLE videos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  youtube_id VARCHAR(50),
  title VARCHAR(255) NOT NULL,
  description TEXT,
  thumbnail_url TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Songs (Worship music)
CREATE TABLE songs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  youtube_id VARCHAR(50),
  title VARCHAR(255) NOT NULL,
  artist VARCHAR(255),
  thumbnail_url TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Sermons
CREATE TABLE sermons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  pastor VARCHAR(255),
  duration VARCHAR(20),
  video_url TEXT,
  thumbnail_url TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Resources (Library content)
CREATE TABLE resources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  url TEXT NOT NULL,
  resource_type VARCHAR(50) NOT NULL, -- 'article', 'blog', 'website', 'pdf', 'book', 'podcast', 'study'
  author VARCHAR(255),
  tags VARCHAR(100)[],
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);
CREATE INDEX idx_resources_type ON resources(user_id, resource_type);
CREATE INDEX idx_resources_tags ON resources USING gin(tags);

-- Flourishing Scores
CREATE TABLE flourishing_scores (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  health_score INTEGER CHECK (health_score BETWEEN 0 AND 100),
  relationships_score INTEGER CHECK (relationships_score BETWEEN 0 AND 100),
  finances_score INTEGER CHECK (finances_score BETWEEN 0 AND 100),
  meaning_score INTEGER CHECK (meaning_score BETWEEN 0 AND 100),
  happiness_score INTEGER CHECK (happiness_score BETWEEN 0 AND 100),
  character_score INTEGER CHECK (character_score BETWEEN 0 AND 100),
  faith_score INTEGER CHECK (faith_score BETWEEN 0 AND 100),
  overall_index INTEGER CHECK (overall_index BETWEEN 0 AND 100),
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Personalization Runs (Track AI recommendation jobs)
CREATE TABLE personalization_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  engine_type VARCHAR(50) NOT NULL, -- 'bible_verse', 'devotional', 'video', 'song', 'sermon', 'resource', 'flourishing'
  input_data JSONB, -- Events and context used
  output_data JSONB, -- Raw AI response
  status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'completed', 'failed'
  created_at TIMESTAMP DEFAULT NOW()
);
```

---

## Predefined Spiritual Guides

Insert these 6 guides on database initialization:

```sql
INSERT INTO spiritual_guides (name, description, system_prompt, avatar_emoji) VALUES
(
  'Biblical Scholar',
  'Deep theological knowledge and scripture interpretation',
  'You are a Biblical Scholar with deep knowledge of theology, church history, and biblical languages. Provide scholarly yet accessible explanations of scripture. Always cite specific verses. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üìñ'
),
(
  'Relationship Guide',
  'Wisdom for relationships, marriage, and family',
  'You are a Relationship Guide specializing in Christian perspectives on marriage, family, friendships, and community. Provide practical, biblically-grounded advice. Be warm and empathetic. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üíë'
),
(
  'Prayer Counselor',
  'Guidance on prayer life and spiritual disciplines',
  'You are a Prayer Counselor helping people deepen their prayer life and spiritual disciplines. Offer practical steps and encouragement. Be gentle and supportive. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üôè'
),
(
  'Career & Purpose Coach',
  'Finding God''s calling in work and life purpose',
  'You are a Career & Purpose Coach helping people discover God''s calling in their professional life. Blend spiritual wisdom with practical career advice. Be encouraging and action-oriented. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üíº'
),
(
  'Mental Wellness Guide',
  'Faith-based support for anxiety, stress, and emotions',
  'You are a Mental Wellness Guide offering faith-based support for anxiety, stress, depression, and emotional struggles. Be compassionate and non-judgmental. Always encourage professional help when needed. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üß†'
),
(
  'Worship & Creativity',
  'Exploring faith through art, music, and creative expression',
  'You are a Worship & Creativity guide helping people express faith through music, art, and creativity. Inspire and encourage creative spiritual practices. Be enthusiastic and affirming. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üé®'
);
```

---

## Authentication

Implement simple email/password authentication:

1. **Registration**: Accept email, password, and optional name. Hash password with bcrypt before storing in database.
2. **Login**: Verify email exists, compare password hash, create session.
3. **Session Management**: Use secure HTTP-only cookies for session tokens.
4. **Route Protection**: Add authentication middleware to all API routes to verify valid session before processing requests.

---

## Personalization Engines

### How They Work

1. **Triggered**: Manually (user clicks refresh) or automatically (scheduled background jobs)
2. **Process**: 
   - Fetch recent events from `events` table for the user
   - Call OpenAI API with specialized system prompt
   - Parse JSON response
   - Save to `personalization_runs` table
   - Insert recommendations into target table with `personalization_run_id`

### System Prompts for Each Engine

#### 1. Bible Verse Engine

```javascript
const systemPrompt = `You are a Bible recommendation AI. Based on user's recent spiritual activities, recommend ONE Bible verse.

CRITICAL RULES:
1. Return ONLY valid JSON. NO explanatory text before or after.
2. Use this EXACT structure:
{
  "book": "John",
  "chapter": 3,
  "verse_start": 16,
  "verse_end": 17,
  "translation": "NIV",
  "reason": "Brief explanation of why this verse fits their journey"
}

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
```

#### 2. Devotional Engine

```javascript
const systemPrompt = `You are a devotional content creator. Based on user's spiritual journey, create ONE personalized devotional.

CRITICAL RULES:
1. Return ONLY valid JSON. NO explanatory text before or after.
2. Use this EXACT structure:
{
  "title": "Short, inspiring title",
  "content": "2-3 paragraph devotional reflection (max 300 words)",
  "scripture_reference": "Hebrews 11:1"
}

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
```

#### 3. Video Recommendation Engine

```javascript
const systemPrompt = `You are a Christian content curator. Based on user's interests, recommend 3-5 relevant YouTube videos.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "title": "Video title",
    "description": "Brief description of content and relevance",
    "search_query": "Exact YouTube search terms to find this video"
  }
]

User's recent activities:
{{EVENTS_SUMMARY}}

Recommend videos about sermons, teachings, worship, testimonies, or Christian living. Respond with JSON only.`;
```

#### 4. Song Recommendation Engine

```javascript
const systemPrompt = `You are a worship music curator. Based on user's mood and spiritual state, recommend 3-5 worship songs.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "title": "Song title",
    "artist": "Artist name",
    "search_query": "Exact YouTube search terms"
  }
]

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
```

#### 5. Sermon Recommendation Engine

```javascript
const systemPrompt = `You are a sermon curator. Based on user's spiritual needs, recommend 3 relevant sermons.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "title": "Sermon title",
    "pastor": "Pastor name",
    "description": "What makes this sermon relevant",
    "search_query": "Exact YouTube search terms"
  }
]

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
```

#### 6. Resource Recommendation Engine (Library)

```javascript
const systemPrompt = `You are a Christian resource curator. Based on user's spiritual journey and interests, recommend 5-8 diverse resources for spiritual growth.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "title": "Resource title",
    "description": "Brief description of content and why it's relevant (max 100 words)",
    "url": "https://example.com/resource",
    "resource_type": "article|blog|website|pdf|book|podcast|study",
    "author": "Author name (if applicable)",
    "tags": ["theology", "prayer", "discipleship"]
  }
]

Resource types explained:
- article: Long-form written content from magazines/journals
- blog: Blog posts and shorter online articles
- website: Comprehensive websites or portals
- pdf: Downloadable PDF documents, ebooks
- book: Physical or digital books (provide purchase/library link)
- podcast: Audio content series or episodes
- study: Bible studies, courses, or structured learning materials

User's recent activities:
{{EVENTS_SUMMARY}}

Provide diverse resource types. Include reputable Christian publishers, ministries, and authors. Ensure URLs are real and accessible. Respond with JSON only.`;
```

#### 7. Flourishing Score Engine

```javascript
const systemPrompt = `You are a human flourishing analyst. Based on user's recent activities, assign scores (0-100) for each flourishing dimension.

CRITICAL RULES:
1. Return ONLY valid JSON. NO explanatory text before or after.
2. Use this EXACT structure:
{
  "health_score": 85,
  "relationships_score": 72,
  "finances_score": 68,
  "meaning_score": 82,
  "happiness_score": 76,
  "character_score": 79,
  "faith_score": 84,
  "overall_index": 78,
  "insights": "Brief observation about their flourishing state"
}

Scoring guidelines:
- 80-100: Thriving
- 60-79: Stable
- 40-59: Struggling
- 0-39: Crisis

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
```

---

## Event Tracking Middleware

**When to create events:**

```javascript
// After user saves a mood
await createEvent(userId, 'mood', { mood_type: 'joyful', notes: '...' });

// After user saves a prayer
await createEvent(userId, 'prayer', { content: '...', is_answered: false });

// After user reads a Bible verse
await createEvent(userId, 'bible_read', { book: 'John', chapter: 3, verses: '16-17' });

// After user reads a devotional
await createEvent(userId, 'devotional_read', { title: '...', was_personalized: true });

// After user creates a note
await createEvent(userId, 'note_created', { tags: ['prayer', 'faith'] });

// After user sends message to spiritual guide
await createEvent(userId, 'guide_chat', { guide_name: 'Biblical Scholar', message_preview: '...' });

// After user watches a video
await createEvent(userId, 'video_watched', { title: '...', duration: '12:30' });

// After user listens to a song
await createEvent(userId, 'song_listened', { title: '...', artist: '...' });

// After user clicks/reads a resource
await createEvent(userId, 'resource_read', { title: '...', resource_type: 'article', url: '...' });
```

**Helper function:**

```javascript
async function createEvent(userId, eventType, eventData) {
  await db.query(
    'INSERT INTO events (user_id, event_type, event_data) VALUES ($1, $2, $3)',
    [userId, eventType, JSON.stringify(eventData)]
  );
}
```

---

## Personalization Engine Implementation

### Example: Bible Verse Engine

```javascript
async function runBibleVerseEngine(userId) {
  // 1. Get recent events
  const events = await db.query(
    'SELECT event_type, event_data, created_at FROM events WHERE user_id = $1 ORDER BY created_at DESC LIMIT 20',
    [userId]
  );
  
  const eventsSummary = events.rows.map(e => 
    `${e.event_type}: ${JSON.stringify(e.event_data)}`
  ).join('\n');
  
  // 2. Create personalization run
  const run = await db.query(
    'INSERT INTO personalization_runs (user_id, engine_type, input_data, status) VALUES ($1, $2, $3, $4) RETURNING id',
    [userId, 'bible_verse', JSON.stringify({ events_count: events.rows.length }), 'pending']
  );
  const runId = run.rows[0].id;
  
  try {
    // 3. Call OpenAI
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: systemPrompt.replace('{{EVENTS_SUMMARY}}', eventsSummary)
          },
          {
            role: 'user',
            content: 'Generate a Bible verse recommendation based on my recent activities.'
          }
        ],
        temperature: 0.7,
        max_tokens: 300
      })
    });
    
    const data = await response.json();
    const aiResponse = data.choices[0].message.content;
    
    // 4. Parse JSON response
    const verse = JSON.parse(aiResponse);
    
    // 5. Save to personalization_runs
    await db.query(
      'UPDATE personalization_runs SET output_data = $1, status = $2 WHERE id = $3',
      [JSON.stringify(verse), 'completed', runId]
    );
    
    // 6. Save to bible_verses table
    await db.query(
      `INSERT INTO bible_verses (user_id, book, chapter, verse_start, verse_end, translation, notes, personalization_run_id) 
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [userId, verse.book, verse.chapter, verse.verse_start, verse.verse_end, verse.translation, verse.reason, runId]
    );
    
    return { success: true, verse };
    
  } catch (error) {
    // Mark run as failed
    await db.query(
      'UPDATE personalization_runs SET status = $1 WHERE id = $2',
      ['failed', runId]
    );
    throw error;
  }
}
```

### Example: Resource Recommendation Engine

```javascript
async function runResourceEngine(userId) {
  // 1. Get recent events
  const events = await db.query(
    'SELECT event_type, event_data, created_at FROM events WHERE user_id = $1 ORDER BY created_at DESC LIMIT 20',
    [userId]
  );
  
  const eventsSummary = events.rows.map(e => 
    `${e.event_type}: ${JSON.stringify(e.event_data)}`
  ).join('\n');
  
  // 2. Create personalization run
  const run = await db.query(
    'INSERT INTO personalization_runs (user_id, engine_type, input_data, status) VALUES ($1, $2, $3, $4) RETURNING id',
    [userId, 'resource', JSON.stringify({ events_count: events.rows.length }), 'pending']
  );
  const runId = run.rows[0].id;
  
  try {
    // 3. Call OpenAI
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: resourceSystemPrompt.replace('{{EVENTS_SUMMARY}}', eventsSummary)
          },
          {
            role: 'user',
            content: 'Generate resource recommendations based on my recent activities.'
          }
        ],
        temperature: 0.7,
        max_tokens: 1500
      })
    });
    
    const data = await response.json();
    const aiResponse = data.choices[0].message.content;
    
    // 4. Parse JSON response
    const resources = JSON.parse(aiResponse);
    
    // 5. Save to personalization_runs
    await db.query(
      'UPDATE personalization_runs SET output_data = $1, status = $2 WHERE id = $3',
      [JSON.stringify(resources), 'completed', runId]
    );
    
    // 6. Save each resource to resources table
    for (const resource of resources) {
      await db.query(
        `INSERT INTO resources (user_id, title, description, url, resource_type, author, tags, personalization_run_id) 
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        [
          userId, 
          resource.title, 
          resource.description, 
          resource.url, 
          resource.resource_type, 
          resource.author || null,
          resource.tags || [],
          runId
        ]
      );
    }
    
    return { success: true, resources };
    
  } catch (error) {
    // Mark run as failed
    await db.query(
      'UPDATE personalization_runs SET status = $1 WHERE id = $2',
      ['failed', runId]
    );
    throw error;
  }
}
```

**Apply the same pattern for all other engines**, just change:
- `engine_type` parameter
- Target table for saving results
- System prompt
- JSON parsing logic

---

## API Routes Structure

```
/api/auth/register - POST (email, password, name)
/api/auth/login - POST (email, password)

/api/moods - GET (list), POST (create)
/api/prayers - GET (list), POST (create), PATCH (mark answered)
/api/devotionals - GET (list), POST (refresh/generate new)
/api/bible-verses - GET (current), POST (save), POST /generate (run engine)
/api/notes - GET (list), POST (create), PATCH (update)

/api/guides - GET (list all guides)
/api/conversations - GET (list for user), POST (start new)
/api/conversations/[id]/messages - GET (load history), POST (send message)

/api/prayer-chains - GET (public list), POST (create)
/api/prayer-chains/[id]/comments - GET, POST

/api/videos - GET (personalized list), POST /generate (run engine)
/api/songs - GET (personalized list), POST /generate (run engine)
/api/sermons - GET (personalized list), POST /generate (run engine)
/api/resources - GET (personalized list with filters), POST /generate (run engine)

/api/flourishing - GET (latest scores), POST /generate (run engine)

/api/personalize/run - POST (engine_type) - Manual trigger for any engine
```

---

## Library (Resources) Window UI Structure

The Library window should display a searchable, filterable list of resources:

### UI Components:

1. **Search Bar**: Free text search across title, description, author
2. **Filter Buttons**: 
   - All Resources
   - Articles
   - Blogs
   - Websites
   - PDFs
   - Books
   - Podcasts
   - Studies

3. **Refresh Button**: Triggers resource personalization engine to generate new recommendations

4. **Resource List View**: Each resource displays:
   - Icon based on resource_type (üìÑ article, ‚úçÔ∏è blog, üåê website, üìï pdf, üìö book, üéôÔ∏è podcast, üìñ study)
   - Title (clickable, opens URL in new tab)
   - Author (if available)
   - Description (truncated with "Read more" if long)
   - Tags (as colored pills)
   - Timestamp

### Frontend Implementation Example:

```javascript
// Resource type icons mapping
const resourceIcons = {
  article: 'üìÑ',
  blog: '‚úçÔ∏è',
  website: 'üåê',
  pdf: 'üìï',
  book: 'üìö',
  podcast: 'üéôÔ∏è',
  study: 'üìñ'
};

// Filter resources by type
const [selectedType, setSelectedType] = useState('all');
const [searchQuery, setSearchQuery] = useState('');

const filteredResources = resources.filter(resource => {
  const matchesType = selectedType === 'all' || resource.resource_type === selectedType;
  const matchesSearch = resource.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                        resource.description.toLowerCase().includes(searchQuery.toLowerCase());
  return matchesType && matchesSearch;
});
```

### API Endpoint for Resources with Filters:

```
GET /api/resources?type=article&search=prayer&limit=20
```

Query parameters:
- `type`: Filter by resource_type (optional, defaults to all)
- `search`: Free text search (optional)
- `limit`: Number of resources to return (optional, defaults to 20)

---

## Key Implementation Notes

### 1. Personalization Runs
- Store raw AI output in `output_data` JSONB field
- Always link recommendations back to the run via `personalization_run_id`
- This allows rebuilding and debugging recommendations

### 2. Events Table Design
- `event_data` is JSONB for flexibility
- Keep events lightweight (don't duplicate entire content)
- Add indexes on `user_id` and `created_at` for performance

### 3. Error Handling for AI Calls
- Always wrap OpenAI calls in try-catch
- Mark runs as 'failed' on error
- Provide fallback content if personalization fails

### 4. YouTube Integration
- For now, store `search_query` instead of actual YouTube IDs
- Use YouTube Data API later to fetch real video metadata
- Save `youtube_id` once implemented for direct embedding

### 5. Flourishing Scores
- Run engine once per day automatically (background cron job)
- Allow manual refresh with cooldown (max once per hour)
- Display most recent score in UI

### 6. Resource URLs
- Validate URLs before saving to database
- Track clicks on resources by creating events
- Consider adding a "read later" or "favorite" feature in future iterations

---

## UI Integration

1. **Convert HTML to React components** - Keep the same TailwindCSS classes
2. **Use React state** for window management (no localStorage needed)
3. **Fetch data from API routes** using standard fetch or data fetching library
4. **Real-time updates** - Poll APIs or use WebSockets for prayer chains

---

## Initial Data Flow Example

**User logs in ‚Üí Views Bible window:**

1. Frontend fetches `/api/bible-verses` (GET)
2. If no verse exists or user clicks refresh, call `/api/bible-verses/generate` (POST)
3. Backend runs `runBibleVerseEngine(userId)`
4. Engine fetches events, calls OpenAI, parses response, saves to DB
5. Frontend receives new verse and displays it

**User opens Library window:**

1. Frontend fetches `/api/resources` (GET)
2. If no resources exist or user clicks refresh, call `/api/resources/generate` (POST)
3. Backend runs `runResourceEngine(userId)`
4. Engine fetches events, calls OpenAI, parses response, saves multiple resources to DB
5. Frontend receives resources and displays filterable list
6. User clicks on a resource ‚Üí opens URL in new tab and creates 'resource_read' event

**This same pattern applies to devotionals, videos, songs, sermons, and flourishing scores.**

---

## Testing the System

1. Register a new user
2. Log a few moods (creates events)
3. Save some prayers (creates events)
4. Open Bible window, click refresh ‚Üí should get personalized verse
5. Open Devotionals window, click refresh ‚Üí should get personalized devotional
6. Open Library window, click refresh ‚Üí should get 5-8 diverse resources
7. Filter resources by type (articles, blogs, etc.)
8. Search resources by keyword
9. Click on a resource ‚Üí opens URL and tracks event
10. Check flourishing scores ‚Üí should see calculated metrics

---

**This is a complete, production-ready specification for Harmony. Follow it exactly to avoid over-complication. Every instruction is precise and ready for implementation.**