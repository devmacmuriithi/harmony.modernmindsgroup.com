Harmony - Implementation Instructions
Overview
Harmony is a faith-based productivity app with personalized AI recommendations. Users track moods, prayers, Bible reading, and interact with AI spiritual guides. The system learns from user activities to provide personalized content for spiritual growth and human flourishing.

Database Schema
Core Tables
sql-- Users
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  name VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Events (Central tracking table)
CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  event_type VARCHAR(50) NOT NULL, -- 'mood', 'prayer', 'bible_read', 'devotional_read', 'note_created', 'guide_chat', 'video_watched', 'song_listened', 'resource_read'
  event_data JSONB, -- Flexible storage for event details
  created_at TIMESTAMP DEFAULT NOW()
);
CREATE INDEX idx_events_user_created ON events(user_id, created_at DESC);

-- Moods
CREATE TABLE moods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  mood_type VARCHAR(50) NOT NULL, -- 'joyful', 'peaceful', 'grateful', 'sad', 'anxious', 'angry'
  notes TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Prayer Journals
CREATE TABLE prayer_journals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  is_answered BOOLEAN DEFAULT FALSE,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  answered_at TIMESTAMP
);

-- Devotionals
CREATE TABLE devotionals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255),
  content TEXT NOT NULL,
  scripture_reference VARCHAR(100),
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Bible Verses
CREATE TABLE bible_verses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  book VARCHAR(50) NOT NULL,
  chapter INTEGER NOT NULL,
  verse_start INTEGER NOT NULL,
  verse_end INTEGER,
  translation VARCHAR(10) DEFAULT 'NIV',
  notes TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Sync Notes
CREATE TABLE sync_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  ai_tags VARCHAR(100)[], -- Array of tag strings
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Spiritual Guides (Predefined agents)
CREATE TABLE spiritual_guides (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  description TEXT,
  system_prompt TEXT NOT NULL,
  avatar_emoji VARCHAR(10) DEFAULT 'üïäÔ∏è',
  created_at TIMESTAMP DEFAULT NOW()
);

-- Conversations (Chat sessions with guides)
CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  guide_id UUID REFERENCES spiritual_guides(id) ON DELETE CASCADE,
  title VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Messages (Chat messages)
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
  role VARCHAR(20) NOT NULL, -- 'user', 'assistant', 'system'
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Prayer Chains (Public prayer requests)
CREATE TABLE prayer_chains (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  is_answered BOOLEAN DEFAULT FALSE,
  follower_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Prayer Chain Comments
CREATE TABLE prayer_chain_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  prayer_chain_id UUID REFERENCES prayer_chains(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Videos (YouTube recommendations)
CREATE TABLE videos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  youtube_id VARCHAR(50) NOT NULL,
  youtube_url TEXT NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  channel_name VARCHAR(255),
  thumbnail_url TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Songs (Worship music)
CREATE TABLE songs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  youtube_id VARCHAR(50) NOT NULL,
  youtube_url TEXT NOT NULL,
  title VARCHAR(255) NOT NULL,
  artist VARCHAR(255),
  thumbnail_url TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Sermons
CREATE TABLE sermons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  youtube_id VARCHAR(50) NOT NULL,
  youtube_url TEXT NOT NULL,
  title VARCHAR(255) NOT NULL,
  pastor VARCHAR(255),
  church_name VARCHAR(255),
  duration VARCHAR(20),
  thumbnail_url TEXT,
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Resources (Library content)
CREATE TABLE resources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  url TEXT NOT NULL,
  resource_type VARCHAR(50) NOT NULL, -- 'article', 'blog', 'website', 'pdf', 'book', 'podcast', 'study'
  author VARCHAR(255),
  tags VARCHAR(100)[],
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);
CREATE INDEX idx_resources_type ON resources(user_id, resource_type);
CREATE INDEX idx_resources_tags ON resources USING gin(tags);

-- Flourishing Scores
CREATE TABLE flourishing_scores (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  health_score INTEGER CHECK (health_score BETWEEN 0 AND 100),
  relationships_score INTEGER CHECK (relationships_score BETWEEN 0 AND 100),
  finances_score INTEGER CHECK (finances_score BETWEEN 0 AND 100),
  meaning_score INTEGER CHECK (meaning_score BETWEEN 0 AND 100),
  happiness_score INTEGER CHECK (happiness_score BETWEEN 0 AND 100),
  character_score INTEGER CHECK (character_score BETWEEN 0 AND 100),
  faith_score INTEGER CHECK (faith_score BETWEEN 0 AND 100),
  overall_index INTEGER CHECK (overall_index BETWEEN 0 AND 100),
  personalization_run_id UUID,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Personalization Runs (Track AI recommendation jobs)
CREATE TABLE personalization_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  engine_type VARCHAR(50) NOT NULL, -- 'bible_verse', 'devotional', 'video', 'song', 'sermon', 'resource', 'flourishing'
  input_data JSONB, -- Events and context used
  output_data JSONB, -- Raw AI response
  status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'completed', 'failed'
  created_at TIMESTAMP DEFAULT NOW()
);

Predefined Spiritual Guides
Insert these 6 guides on database initialization:
sqlINSERT INTO spiritual_guides (name, description, system_prompt, avatar_emoji) VALUES
(
  'Biblical Scholar',
  'Deep theological knowledge and scripture interpretation',
  'You are a Biblical Scholar with deep knowledge of theology, church history, and biblical languages. Provide scholarly yet accessible explanations of scripture. Always cite specific verses. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üìñ'
),
(
  'Relationship Guide',
  'Wisdom for relationships, marriage, and family',
  'You are a Relationship Guide specializing in Christian perspectives on marriage, family, friendships, and community. Provide practical, biblically-grounded advice. Be warm and empathetic. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üíë'
),
(
  'Prayer Counselor',
  'Guidance on prayer life and spiritual disciplines',
  'You are a Prayer Counselor helping people deepen their prayer life and spiritual disciplines. Offer practical steps and encouragement. Be gentle and supportive. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üôè'
),
(
  'Career & Purpose Coach',
  'Finding God''s calling in work and life purpose',
  'You are a Career & Purpose Coach helping people discover God''s calling in their professional life. Blend spiritual wisdom with practical career advice. Be encouraging and action-oriented. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üíº'
),
(
  'Mental Wellness Guide',
  'Faith-based support for anxiety, stress, and emotions',
  'You are a Mental Wellness Guide offering faith-based support for anxiety, stress, depression, and emotional struggles. Be compassionate and non-judgmental. Always encourage professional help when needed. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üß†'
),
(
  'Worship & Creativity',
  'Exploring faith through art, music, and creative expression',
  'You are a Worship & Creativity guide helping people express faith through music, art, and creativity. Inspire and encourage creative spiritual practices. Be enthusiastic and affirming. Keep responses under 200 words. NEVER include any preamble or post-text. Respond ONLY with the direct answer in plain text.',
  'üé®'
);

Authentication
Implement simple email/password authentication:

Registration: Accept email, password, and optional name. Hash password with bcrypt before storing in database.
Login: Verify email exists, compare password hash, create session.
Session Management: Use secure HTTP-only cookies for session tokens.
Route Protection: Add authentication middleware to all API routes to verify valid session before processing requests.


Personalization Engines
How They Work

Triggered: Manually (user clicks refresh) or automatically (scheduled background jobs)
Process:

Fetch recent events from events table for the user
Call OpenAI API with specialized system prompt
Parse JSON response
Save to personalization_runs table
Insert recommendations into target table with personalization_run_id



System Prompts for Each Engine
1. Bible Verse Engine
javascriptconst systemPrompt = `You are a Bible recommendation AI. Based on user's recent spiritual activities, recommend ONE Bible verse.

CRITICAL RULES:
1. Return ONLY valid JSON. NO explanatory text before or after.
2. Use this EXACT structure:
{
  "book": "John",
  "chapter": 3,
  "verse_start": 16,
  "verse_end": 17,
  "translation": "NIV",
  "reason": "Brief explanation of why this verse fits their journey"
}

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
2. Devotional Engine
javascriptconst systemPrompt = `You are a devotional content creator. Based on user's spiritual journey, create ONE personalized devotional.

CRITICAL RULES:
1. Return ONLY valid JSON. NO explanatory text before or after.
2. Use this EXACT structure:
{
  "title": "Short, inspiring title",
  "content": "2-3 paragraph devotional reflection (max 300 words)",
  "scripture_reference": "Hebrews 11:1"
}

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
3. Video Recommendation Engine
javascriptconst systemPrompt = `You are a Christian content curator. Based on user's interests, recommend 3-5 relevant YouTube videos.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "youtube_id": "dQw4w9WgXcQ",
    "youtube_url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
    "title": "Video title",
    "description": "Brief description of content and relevance",
    "channel_name": "Channel name",
    "thumbnail_url": "https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg"
  }
]

IMPORTANT: 
- Provide REAL YouTube video IDs that you know exist
- Use the format: https://www.youtube.com/watch?v={VIDEO_ID}
- Thumbnail URL format: https://img.youtube.com/vi/{VIDEO_ID}/maxresdefault.jpg
- Only recommend videos you are confident exist on YouTube

User's recent activities:
{{EVENTS_SUMMARY}}

Recommend videos about sermons, teachings, worship, testimonies, or Christian living. Respond with JSON only.`;
4. Song Recommendation Engine
javascriptconst systemPrompt = `You are a worship music curator. Based on user's mood and spiritual state, recommend 3-5 worship songs.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "youtube_id": "dQw4w9WgXcQ",
    "youtube_url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
    "title": "Song title",
    "artist": "Artist name",
    "thumbnail_url": "https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg"
  }
]

IMPORTANT: 
- Provide REAL YouTube video IDs for worship songs that you know exist
- Use the format: https://www.youtube.com/watch?v={VIDEO_ID}
- Thumbnail URL format: https://img.youtube.com/vi/{VIDEO_ID}/maxresdefault.jpg
- Only recommend songs you are confident exist on YouTube

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
5. Sermon Recommendation Engine
javascriptconst systemPrompt = `You are a sermon curator. Based on user's spiritual needs, recommend 3 relevant sermons.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "youtube_id": "dQw4w9WgXcQ",
    "youtube_url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
    "title": "Sermon title",
    "pastor": "Pastor name",
    "church_name": "Church name",
    "duration": "45:30",
    "thumbnail_url": "https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg"
  }
]

IMPORTANT: 
- Provide REAL YouTube video IDs for sermons that you know exist
- Use the format: https://www.youtube.com/watch?v={VIDEO_ID}
- Thumbnail URL format: https://img.youtube.com/vi/{VIDEO_ID}/maxresdefault.jpg
- Only recommend sermons you are confident exist on YouTube
- Include estimated duration in MM:SS or HH:MM:SS format

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;
6. Resource Recommendation Engine (Library)
javascriptconst systemPrompt = `You are a Christian resource curator. Based on user's spiritual journey and interests, recommend 5-8 diverse resources for spiritual growth.

CRITICAL RULES:
1. Return ONLY valid JSON array. NO explanatory text before or after.
2. Use this EXACT structure:
[
  {
    "title": "Resource title",
    "description": "Brief description of content and why it's relevant (max 100 words)",
    "url": "https://example.com/resource",
    "resource_type": "article|blog|website|pdf|book|podcast|study",
    "author": "Author name (if applicable)",
    "tags": ["theology", "prayer", "discipleship"]
  }
]

Resource types explained:
- article: Long-form written content from magazines/journals
- blog: Blog posts and shorter online articles
- website: Comprehensive websites or portals
- pdf: Downloadable PDF documents, ebooks
- book: Physical or digital books (provide purchase/library link)
- podcast: Audio content series or episodes
- study: Bible studies, courses, or structured learning materials

User's recent activities:
{{EVENTS_SUMMARY}}

Provide diverse resource types. Include reputable Christian publishers, ministries, and authors. Ensure URLs are real and accessible. Respond with JSON only.`;
7. Flourishing Score Engine
javascriptconst systemPrompt = `You are a human flourishing analyst. Based on user's recent activities, assign scores (0-100) for each flourishing dimension.

CRITICAL RULES:
1. Return ONLY valid JSON. NO explanatory text before or after.
2. Use this EXACT structure:
{
  "health_score": 85,
  "relationships_score": 72,
  "finances_score": 68,
  "meaning_score": 82,
  "happiness_score": 76,
  "character_score": 79,
  "faith_score": 84,
  "overall_index": 78,
  "insights": "Brief observation about their flourishing state"
}

Scoring guidelines:
- 80-100: Thriving
- 60-79: Stable
- 40-59: Struggling
- 0-39: Crisis

User's recent activities:
{{EVENTS_SUMMARY}}

Respond with JSON only.`;

Event Tracking Middleware
When to create events:
javascript// After user saves a mood
await createEvent(userId, 'mood', { mood_type: 'joyful', notes: '...' });

// After user saves a prayer
await createEvent(userId, 'prayer', { content: '...', is_answered: false });

// After user reads a Bible verse
await createEvent(userId, 'bible_read', { book: 'John', chapter: 3, verses: '16-17' });

// After user reads a devotional
await createEvent(userId, 'devotional_read', { title: '...', was_personalized: true });

// After user creates a note
await createEvent(userId, 'note_created', { tags: ['prayer', 'faith'] });

// After user sends message to spiritual guide
await createEvent(userId, 'guide_chat', { guide_name: 'Biblical Scholar', message_preview: '...' });

// After user watches a video
await createEvent(userId, 'video_watched', { title: '...', youtube_id: 'abc123' });

// After user listens to a song
await createEvent(userId, 'song_listened', { title: '...', artist: '...', youtube_id: 'xyz789' });

// After user clicks/reads a resource
await createEvent(userId, 'resource_read', { title: '...', resource_type: 'article', url: '...' });
Helper function:
javascriptasync function createEvent(userId, eventType, eventData) {
  await db.query(
    'INSERT INTO events (user_id, event_type, event_data) VALUES ($1, $2, $3)',
    [userId, eventType, JSON.stringify(eventData)]
  );
}

Personalization Engine Implementation
Example: Bible Verse Engine
javascriptasync function runBibleVerseEngine(userId) {
  // 1. Get recent events
  const events = await db.query(
    'SELECT event_type, event_data, created_at FROM events WHERE user_id = $1 ORDER BY created_at DESC LIMIT 20',
    [userId]
  );
  
  const eventsSummary = events.rows.map(e => 
    `${e.event_type}: ${JSON.stringify(e.event_data)}`
  ).join('\n');
  
  // 2. Create personalization run
  const run = await db.query(
    'INSERT INTO personalization_runs (user_id, engine_type, input_data, status) VALUES ($1, $2, $3, $4) RETURNING id',
    [userId, 'bible_verse', JSON.stringify({ events_count: events.rows.length }), 'pending']
  );
  const runId = run.rows[0].id;
  
  try {
    // 3. Call OpenAI
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: systemPrompt.replace('{{EVENTS_SUMMARY}}', eventsSummary)
          },
          {
            role: 'user',
            content: 'Generate a Bible verse recommendation based on my recent activities.'
          }
        ],
        temperature: 0.7,
        max_tokens: 300
      })
    });
    
    const data = await response.json();
    const aiResponse = data.choices[0].message.content;
    
    // 4. Parse JSON response
    const verse = JSON.parse(aiResponse);
    
    // 5. Save to personalization_runs
    await db.query(
      'UPDATE personalization_runs SET output_data = $1, status = $2 WHERE id = $3',
      [JSON.stringify(verse), 'completed', runId]
    );
    
    // 6. Save to bible_verses table
    await db.query(
      `INSERT INTO bible_verses (user_id, book, chapter, verse_start, verse_end, translation, notes, personalization_run_id) 
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [userId, verse.book, verse.chapter, verse.verse_start, verse.verse_end, verse.translation, verse.reason, runId]
    );
    
    return { success: true, verse };
    
  } catch (error) {
    // Mark run as failed
    await db.query(
      'UPDATE personalization_runs SET status = $1 WHERE id = $2',
      ['failed', runId]
    );
    throw error;
  }
}
Example: Video Recommendation Engine
javascriptasync function runVideoEngine(userId) {
  // 1. Get recent events
  const events = await db.query(
    'SELECT event_type, event_data, created_at FROM events WHERE user_id = $1 ORDER BY created_at DESC LIMIT 20',
    [userId]
  );
  
  const eventsSummary = events.rows.map(e => 
    `${e.event_type}: ${JSON.stringify(e.event_data)}`
  ).join('\n');
  
  // 2. Create personalization run
  const run = await db.query(
    'INSERT INTO personalization_runs (user_id, engine_type, input_data, status) VALUES ($1, $2, $3, $4) RETURNING id',
    [userId, 'video', JSON.stringify({ events_count: events.rows.length }), 'pending']
  );
  const runId = run.rows[0].id;
  
  try {
    // 3. Call OpenAI
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: videoSystemPrompt.replace('{{EVENTS_SUMMARY}}', eventsSummary)
          },
          {
            role: 'user',
            content: 'Generate video recommendations based on my recent activities.'
          }
        ],
        temperature: 0.7,
        max_tokens: 1500
      })
    });
    
    const data = await response.json();
    const aiResponse = data.choices[0].message.content;
    
    // 4. Parse JSON response
    const videos = JSON.parse(aiResponse);
    
    // 5. Save to personalization_runs
    await db.query(
      'UPDATE personalization_runs SET output_data = $1, status = $2 WHERE id = $3',
      [JSON.stringify(videos), 'completed', runId]
    );
    
    // 6. Save each video to videos table
    for (const video of videos) {
      await db.query(
        `INSERT INTO videos (user_id, youtube_id, youtube_url, title, description, channel_name, thumbnail_url, personalization_run_id) 
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        [
          userId, 
          video.youtube_id, 
          video.youtube_url,
          video.title, 
          video.description, 
          video.channel_name || null,
          video.thumbnail_url || null,
          runId
        ]
      );
    }
    
    return { success: true, videos };
    
  } catch (error) {
    // Mark run as failed
    await db.query(
      'UPDATE personalization_runs SET status = $1 WHERE id = $2',
      ['failed', runId]
    );
    throw error;
  }
}
Example: Resource Recommendation Engine
javascriptasync function runResourceEngine(userId) {
  // 1. Get recent events
  const events = await db.query(
    'SELECT event_type, event_data, created_at FROM events WHERE user_id = $1 ORDER BY created_at DESC LIMIT 20',
    [userId]
  );
  
  const eventsSummary = events.rows.map(e => 
    `${e.event_type}: ${JSON.stringify(e.event_data)}`
  ).join('\n');
  
  // 2. Create personalization run
  const run = await db.query(
    'INSERT INTO personalization_runs (user_id, engine_type, input_data, status) VALUES ($1, $2, $3, $4) RETURNING id',
    [userId, 'resource', JSON.stringify({ events_count: events.rows.length }), 'pending']
  );
  const runId = run.rows[0].id;
  
  try {
    // 3. Call OpenAI
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: resourceSystemPrompt.replace('{{EVENTS_SUMMARY}}', eventsSummary)
          },
          {
            role: 'user',
            content: 'Generate resource recommendations based on my recent activities.'
          }
        ],
        temperature: 0.7,
        max_tokens: 1500
      })
    });
    
    const data = await response.json();
    const aiResponse = data.choices[0].message.content;
    
    // 4. Parse JSON response
    const resources = JSON.parse(aiResponse);
    
    // 5. Save to personalization_runs
    await db.query(
      'UPDATE personalization_runs SET output_data = $1, status = $2 WHERE id = $3',
      [JSON.stringify(resources), 'completed', runId]
    );
    
    // 6. Save each resource to resources table
    for (const resource of resources) {
      await db.query(
        `INSERT INTO resources (user_id, title, description, url, resource_type, author, tags, personalization_run_id) 
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        [
          userId, 
          resource.title, 
          resource.description, 
          resource.url, 
          resource.resource_type, 
          resource.author || null,
          resource.tags || [],
          runId
        ]
      );
    }
    
    return { success: true, resources };
    
  } catch (error) {
    // Mark run as failed
    await db.query(
      'UPDATE personalization_runs SET status = $1 WHERE id = $2',
      ['failed', runId]
    );
    throw error;
  }
}
Apply the same pattern for songs and sermons engines, just change:

engine_type parameter
Target table for saving results
System prompt
JSON parsing logic


API Routes Structure
/api/auth/register - POST (email, password, name)
/api/auth/login - POST (email, password)

/api/moods - GET (list), POST (create)
/api/prayers - GET (list), POST (create), PATCH (mark answered)
/api/devotionals - GET (list), POST (refresh/generate new)
/api/bible-verses - GET (current), POST (save), POST /generate (run engine)
/api/notes - GET (list), POST (create), PATCH (update)

/api/guides - GET (list all guides)
/api/conversations - GET (list for user), POST (start new)
/api/conversations/[id]/messages - GET (load history), POST (send message)

/api/prayer-chains - GET (public list), POST (create)
/api/prayer-chains/[id]/comments - GET, POST

/api/videos - GET (personalized list), POST /generate (run engine)
/api/songs - GET (personalized list), POST /generate (run engine)
/api/sermons - GET (personalized list), POST /generate (run engine)
/api/resources - GET (personalized list with filters), POST /generate (run engine)

/api/flourishing - GET (latest scores), POST /generate (run engine)

/api/personalize/run - POST (engine_type) - Manual trigger for any engine

Library (Resources) Window UI Structure
The Library window should display a searchable, filterable list of resources:
UI Components:

Search Bar: Free text search across title, description, author
Filter Buttons:

All Resources
Articles
Blogs
Websites
PDFs
Books
Podcasts
Studies


Refresh Button: Triggers resource personalization engine to generate new recommendations
Resource List View: Each resource displays:

Icon based on resource_type (üìÑ article, ‚úçÔ∏è blog, üåê website,


RetryMMContinueüìï pdf, üìö book, üéôÔ∏è podcast, üìñ study)

Title (clickable, opens URL in new tab)
Author (if available)
Description (truncated with "Read more" if long)
Tags (as colored pills)
Timestamp

Frontend Implementation Example:
javascript// Resource type icons mapping
const resourceIcons = {
  article: 'üìÑ',
  blog: '‚úçÔ∏è',
  website: 'üåê',
  pdf: 'üìï',
  book: 'üìö',
  podcast: 'üéôÔ∏è',
  study: 'üìñ'
};

// Filter resources by type
const [selectedType, setSelectedType] = useState('all');
const [searchQuery, setSearchQuery] = useState('');

const filteredResources = resources.filter(resource => {
  const matchesType = selectedType === 'all' || resource.resource_type === selectedType;
  const matchesSearch = resource.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                        resource.description.toLowerCase().includes(searchQuery.toLowerCase());
  return matchesType && matchesSearch;
});
API Endpoint for Resources with Filters:
GET /api/resources?type=article&search=prayer&limit=20
Query parameters:

type: Filter by resource_type (optional, defaults to all)
search: Free text search (optional)
limit: Number of resources to return (optional, defaults to 20)


Videos, Songs, and Sermons Windows UI Structure
These windows should display YouTube content in a grid/list view:
UI Components for Videos/Songs/Sermons:

Refresh Button: Triggers personalization engine to generate new recommendations
Grid/List View: Each item displays:

Thumbnail image (from thumbnail_url)
Title (clickable, opens YouTube URL in new tab or embedded player)
Channel/Artist/Pastor name
Duration (for sermons)
Description (truncated)


Embedded Player (optional): Click on item to play video inline using YouTube embed:

html   <iframe 
     width="560" 
     height="315" 
     src="https://www.youtube.com/embed/{youtube_id}" 
     frameborder="0" 
     allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
     allowfullscreen>
   </iframe>
Frontend Implementation Example:
javascript// For Videos window
const VideoCard = ({ video }) => (
  <div className="video-card">
    <img src={video.thumbnail_url} alt={video.title} />
    <h3>{video.title}</h3>
    <p className="channel">{video.channel_name}</p>
    <p className="description">{video.description}</p>
    <button onClick={() => window.open(video.youtube_url, '_blank')}>
      Watch on YouTube
    </button>
  </div>
);

// For Songs window
const SongCard = ({ song }) => (
  <div className="song-card">
    <img src={song.thumbnail_url} alt={song.title} />
    <h3>{song.title}</h3>
    <p className="artist">{song.artist}</p>
    <button onClick={() => window.open(song.youtube_url, '_blank')}>
      Listen on YouTube
    </button>
  </div>
);

// For Sermons window
const SermonCard = ({ sermon }) => (
  <div className="sermon-card">
    <img src={sermon.thumbnail_url} alt={sermon.title} />
    <h3>{sermon.title}</h3>
    <p className="pastor">{sermon.pastor} ‚Ä¢ {sermon.church_name}</p>
    <p className="duration">{sermon.duration}</p>
    <button onClick={() => window.open(sermon.youtube_url, '_blank')}>
      Watch Sermon
    </button>
  </div>
);

Key Implementation Notes
1. Personalization Runs

Store raw AI output in output_data JSONB field
Always link recommendations back to the run via personalization_run_id
This allows rebuilding and debugging recommendations

2. Events Table Design

event_data is JSONB for flexibility
Keep events lightweight (don't duplicate entire content)
Add indexes on user_id and created_at for performance

3. Error Handling for AI Calls

Always wrap OpenAI calls in try-catch
Mark runs as 'failed' on error
Provide fallback content if personalization fails

4. YouTube Content Integration

AI provides youtube_id, youtube_url, and thumbnail_url directly
No third-party API calls needed at this stage
Thumbnail URL format: https://img.youtube.com/vi/{VIDEO_ID}/maxresdefault.jpg
YouTube URL format: https://www.youtube.com/watch?v={VIDEO_ID}
Embed URL format: https://www.youtube.com/embed/{VIDEO_ID}

5. Flourishing Scores

Run engine once per day automatically (background cron job)
Allow manual refresh with cooldown (max once per hour)
Display most recent score in UI

6. Resource URLs

Validate URLs before saving to database
Track clicks on resources by creating events
Consider adding a "read later" or "favorite" feature in future iterations

7. Content Validation

If AI provides invalid YouTube IDs, handle gracefully
Display error state in UI for broken thumbnails/videos
Allow users to report broken content


UI Integration

Convert HTML to React components - Keep the same TailwindCSS classes
Use React state for window management (no localStorage needed)
Fetch data from API routes using standard fetch or data fetching library
Real-time updates - Poll APIs or use WebSockets for prayer chains


Initial Data Flow Examples
User logs in ‚Üí Views Bible window:

Frontend fetches /api/bible-verses (GET)
If no verse exists or user clicks refresh, call /api/bible-verses/generate (POST)
Backend runs runBibleVerseEngine(userId)
Engine fetches events, calls OpenAI, parses response, saves to DB
Frontend receives new verse and displays it

User opens Library window:

Frontend fetches /api/resources (GET)
If no resources exist or user clicks refresh, call /api/resources/generate (POST)
Backend runs runResourceEngine(userId)
Engine fetches events, calls OpenAI, parses response, saves multiple resources to DB
Frontend receives resources and displays filterable list
User clicks on a resource ‚Üí opens URL in new tab and creates 'resource_read' event

User opens Videos window:

Frontend fetches /api/videos (GET)
If no videos exist or user clicks refresh, call /api/videos/generate (POST)
Backend runs runVideoEngine(userId)
Engine fetches events, calls OpenAI with video system prompt
AI returns array of videos with youtube_id, youtube_url, title, description, channel_name, thumbnail_url
Backend saves each video to database with personalization_run_id
Frontend displays video grid with thumbnails
User clicks video ‚Üí opens YouTube URL in new tab and creates 'video_watched' event

User opens Songs window:

Frontend fetches /api/songs (GET)
If no songs exist or user clicks refresh, call /api/songs/generate (POST)
Backend runs runSongEngine(userId)
Engine fetches events, calls OpenAI with song system prompt
AI returns array of songs with youtube_id, youtube_url, title, artist, thumbnail_url
Backend saves each song to database with personalization_run_id
Frontend displays song list with thumbnails
User clicks song ‚Üí opens YouTube URL in new tab and creates 'song_listened' event

User opens Sermons window:

Frontend fetches /api/sermons (GET)
If no sermons exist or user clicks refresh, call /api/sermons/generate (POST)
Backend runs runSermonEngine(userId)
Engine fetches events, calls OpenAI with sermon system prompt
AI returns array of sermons with youtube_id, youtube_url, title, pastor, church_name, duration, thumbnail_url
Backend saves each sermon to database with personalization_run_id
Frontend displays sermon grid with thumbnails
User clicks sermon ‚Üí opens YouTube URL in new tab and creates 'video_watched' event

This same pattern applies to devotionals and flourishing scores.

Testing the System

Register a new user
Log a few moods (creates events)
Save some prayers (creates events)
Open Bible window, click refresh ‚Üí should get personalized verse
Open Devotionals window, click refresh ‚Üí should get personalized devotional
Open Library window, click refresh ‚Üí should get 5-8 diverse resources
Filter resources by type (articles, blogs, etc.)
Search resources by keyword
Click on a resource ‚Üí opens URL and tracks event
Open Videos window, click refresh ‚Üí should get 3-5 personalized videos with thumbnails
Click on video ‚Üí opens YouTube in new tab and tracks event
Open Songs window, click refresh ‚Üí should get 3-5 personalized worship songs
Click on song ‚Üí opens YouTube in new tab and tracks event
Open Sermons window, click refresh ‚Üí should get 3 personalized sermons
Click on sermon ‚Üí opens YouTube in new tab and tracks event
Check flourishing scores ‚Üí should see calculated metrics based on all activities


Branding Updates
Update the following references from "HappySync OS" to "Harmony":
HTML/UI Updates:
html<!-- Top Menu Bar -->
<span class="font-bold text-lg">Harmony</span>

<!-- Page Title -->
<title>Harmony - Your Faith Workspace</title>

<!-- Meta Tags (if any) -->
<meta name="description" content="Harmony - A faith-based productivity and spiritual growth platform">
Database Metadata (Optional):
sql-- Add app configuration table
CREATE TABLE app_config (
  key VARCHAR(100) PRIMARY KEY,
  value TEXT,
  updated_at TIMESTAMP DEFAULT NOW()
);

INSERT INTO app_config (key, value) VALUES 
  ('app_name', 'Harmony'),
  ('app_tagline', 'Your Faith Workspace');

Additional Features to Consider (Future Iterations)
1. Favorites/Bookmarks

Allow users to favorite/bookmark videos, songs, sermons, resources
Add is_favorite boolean to respective tables
Create /api/favorites endpoints

2. Sharing

Allow users to share content with other Harmony users
Add sharing functionality for prayer requests, verses, devotionals

3. Notifications

Notify users when prayer requests are answered
Notify when new personalized content is available
Daily devotional notifications

4. Analytics Dashboard

Show user engagement metrics
Track spiritual growth over time
Visualize mood patterns and correlations

5. Community Features

Follow other users
Join public faith circles
Comment on shared content

6. Mobile App

React Native version for iOS/Android
Push notifications for prayer chains
Offline mode for devotionals and verses


Deployment Considerations
Database

Use PostgreSQL 13+ for JSONB and array support
Set up regular backups
Index optimization for large events table

Environment Variables
envDATABASE_URL=postgresql://username:password@host:port/harmony_db
OPENAI_API_KEY=sk-...
SESSION_SECRET=random-secure-string
NODE_ENV=production
Security

Use HTTPS in production
Implement rate limiting on API routes (especially AI generation endpoints)
Sanitize user inputs to prevent SQL injection
Hash passwords with bcrypt (salt rounds: 10-12)
Set secure cookie flags (httpOnly, secure, sameSite)

Performance

Cache personalization results (Redis optional)
Implement pagination for events table
Consider CDN for static assets
Optimize images (thumbnails)

Monitoring

Log all AI API calls and failures
Track personalization engine success rates
Monitor database query performance
Set up error alerting


Error Handling Patterns
API Error Responses
javascript// Success response
{
  "success": true,
  "data": { ... }
}

// Error response
{
  "success": false,
  "error": {
    "code": "PERSONALIZATION_FAILED",
    "message": "Failed to generate recommendations. Please try again.",
    "details": "OpenAI API timeout"
  }
}
Common Error Codes

AUTH_REQUIRED - User not authenticated
INVALID_INPUT - Validation failed
NOT_FOUND - Resource not found
RATE_LIMITED - Too many requests
PERSONALIZATION_FAILED - AI generation failed
DATABASE_ERROR - Database operation failed


Best Practices Summary

Always track events - Every user action should create an event for personalization
Graceful degradation - If AI fails, show cached/default content
Progressive enhancement - Core features work without JavaScript
User feedback - Show loading states during AI generation
Clear error messages - Tell users what went wrong and how to fix it
Data privacy - Never share user's personal prayers/notes publicly without consent
Accessibility - Follow WCAG guidelines for UI components
Testing - Test all personalization engines with diverse event histories


This is the complete, production-ready specification for Harmony. Follow it exactly to avoid over-complication. Every instruction is precise and ready for implementation.RetryMM